#Evaluation#
 Through the process of completing this project, a high level overview of the project can be taken and examined, allowing a full evaluation of this project.
 Firstly, it is worth looking at what has been achieved in the project, with respect to both the original specification written and also to the software as a whole. When looking back at the specification, it has been shown (please refer to the test report) that all of the functional requirements have been satisfied. This has meant the final software produced achieves at least what was initially set. In addition to this, it has been fortunate that time has allowed the addition of originally unspecified features. Such features include the addition of a memory view, which allows the user to gain an insight into the contents of memory. Although the specification has been updated to reflect this, this was not an original feature, but time permitted its integration into the system. Other added features include the addition of windows for labels for example, but also the extensive references available from within the system. These allow the user to retrieve information on what each register should be used for, the instructions available for use within the simulator as well as information on the system as a whole.

 From a design perspective there is one aspect of the system that, has worked extremely well and allows an incredible amount of extensibility from the system. This is the generality of the system with respect to the algorithms that can be run and visualised within the system.

  From personal experience of adding new algorithms to the system, it has proven very straightforward with no consideration of the internals of the system required. New algorithms can be written via the writing of the MIPS code for it; the annotation language then allows easy integration to visual components through straight-forward methods for operations such as swapping, emphasis etc. If a visual component already exists that can be used for visualising an algorithm, then that is the extent of what is required. If a new visualisation needs to be made, that is all that has to be done: it can be written in JavaFX and then used. This has given the system the aforementioned generality by giving the potential to add visualisations for any algorithm desired to be included within the system. Consequently, this had led to the production of a highly flexible system.

 As well as the achievement of the functional requirements, there were also the non-functional requirements to be satisfied. The easiest method of testing said requirements is through the delivery of the software to the users. This is covered in detail in the test report, however, the user's opinions on the software are crucial to the evaluation of the system. Two of the biggest (non-functional) aims of this project was to improve upon the existing software (Spim Simulator) and to also provide a system which was helpful to the students in their understanding of the content of the Computer Systems & Architecture module. When asked both of these questions explicitly, the large majority of students said it was preferable over Spim Simulator and also that it would prove helpful. Additionally, when finding users' favourite visualisation, the results came back with a reasonably even distribution, suggesting that, in general, all of the visualisations provided are proving as useful as each other. In general, user response, signals that performance/usability requirements have been met. Any other non-functional requirements were met simply, by keeping to them, for example, not allowing local file access through the JavaScript annotation language.

 Another aspect of the system which has proven successful is the plan for its development. At no point in this project has time been a major issue, and for the large majority of the time, it could be seen that components/features of the system were being delivered on time. Although this required a fairly dense work rate (arguably any project being conducted in this timescale would require this), the plan was well organised such that the completion of work within this timescale was possible, with minimal bottlenecks within the development plan. It is for this reason, that Simulizer was able to contain the large array of functionality that it has upon delivery of the final product. 

 The previous points have discussed what has been achieved with the system, and how the system has been a success with particular regards to the requirements set out in the specification document. However, to provide a balanced evaluation of the system, a discussion of the aspects that, in hindsight, may not have been achieved in the best way from the beginning. Possibly one of the biggest occurrences of this in the system was a possible underestimation of the precision required to get a large multi-threaded system correct. In particular, earlier on during the development of the system, less attention may have been given to preventing concurrency errors, such as race conditions and deadlock. As a result, this did mean that significant amounts of time nearer the end of the project had to be spent fixing said concurrency errors, and in some cases, certain methods of threading had to be redesigned such that they were more stable and less error prone.

 One more possible improvement that in hindsight may have proven useful is all team members having more knowledge of the whole code base. With no doubt, the separation of work between team members was very effective in maintaining a well-designed system while still providing an efficient workflow. However, later on in development, when most of the threading issues started to appear, certain team members were an unable to provide much aid in fixing these errors, due to their work being separate from the threading design, for example. If every team member had an understanding of the whole system, then this may have aided in the fixing of bugs later on, however, this still had an upside that it enabled certain members to focus on these areas, while other team members worked on other important areas of the project.

 Reaching the end of the project there are two other important aspects to be discussed which add another judgment of the team's success over the last 10 weeks. The first of these is the goal of Simulizer being used as a resource in the Computer Systems & Architecture module in the following years. After discussions/demonstrations of the system with the module leader (Ian Batten), there is a real chance of it being used. He is planning to take a copy of the software once the project timeline is over to take and use to see whether it is suitable. As a result, this may entail further additions/changes being made to Simulizer after the project is over, however, this would signal a significant achievement for the team and for the software, and so this is something the team is more than willing to continue with.

 In addition to this, there is further potential for Simulizer as well. After discussions with the team's tutor and Ian Batten in further, it has been arisen that there is genuine innovation within Simulizer as a teaching resource. Included in this are aspects of the system such as an easy to understand visualisation of a pipeline (something which had previously been described by Ian Batten as difficult to teach), and also the JavaScript annotation language as an effective method of debugging assembly programs at a high level as well as allowing fine grain control over the visualisations displayed on screen as well as allowing explicit changes to the simulator (such as register changes for example). It is for this reason, that potentially, a paper could be written discussing the innovation Simulizer is providing as a teaching and learning resource. Given the teams current stage into their respective academic careers, this would prove to be a great feat, given the relatively short time scale in which Simulizer has been created.

 As a balanced whole, Simulizer can be considered a successful project. It has achieved everything that was originally set to be accomplished (and more so in some cases) and it has been well received by the user base (both sides of it as well). There are some gaps for potential improvement, but given the environment in which Simulizer has been developed, this is almost inevitable.
