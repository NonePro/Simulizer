#Software Design#
##Simulation Design##
For such a relatively large scale system, a well thought out and planned design was crucial to ensuring Simulizer was manageable to program, reducing any unnecessary complexity into the program through bad planning. The design of the software, especially the back-end went through multiple revisions before a final decision was settled upon. In particular, the design for the simulation had multiple design ideas initially. These were both focused on different aspects of the implementation. One of the proposed designs was to fully and faithfully recreate the MIPS block diagram within Java, with Bus classes used for communication between components and separate classes for every single component (and additionally a thread for each stage of the pipeline). The alternative design was to reduce the entire simulation state into essentially one class, and then have a separate class for the visualisation state. As a first attempt, a compromise was made between these two that kept the highly faithful design but reduced the threading in the pipeline.

In order to test this design, implementation began on the design to see if, at a lower level, it was suitable. Fairly soon after, it was realised that this design would not be fully suitable for multiple reasons: Firstly, the method of communication through buses practically added a lot of unwanted complexity to the simulation. There was also a level of unnecessary encapsulation made in some of the classes (in particularly the program counter, which was just a data class, a bad code ‘smell’). This encapsulation would have made the testing of the system incredibly complicated when it needn’t be. Also, it was the design stage that discovered that the Observer/Observable model would not be sufficient to connect the model and views; more information would be needed. Based on this, the design was revised further.

After revising the design further, a design was created which can be viewed below in the first UML class diagram. This design still aimed for a faithful implementation of the processor but, in some cases, smaller components, such as the program counter are not in their own class, rather they are a field in the main CPU class. This design still kept more complex components separate, but gave a central class to work around. This also allowed the easy sending of messages through this central class and also made the components much more easy to unit test, since each major component could be tested in isolation. One could see these revisions as a refactoring for testability. Other features of this design include a much simpler method for changing the operation of the CPU through inheritance and a significantly reduced thread usage, which reduces the complexity of the simulation significantly. The following is the UML class diagram for the simulation design:

<!-- UML Class Diagram here -->
![UML simulation design](segments/uml-simulation.png){width=80%}

In this design, the CPU class is the most important class, providing the central ‘hub’ for all of the other classes in the simulation. With respect to the actual CPU, this class abstractly represents the Control Unit, the Program Counter and the Instruction Register as well as the 32 general purpose registers. At a high level, this class also deals with the Instruction Execution Cycle. The fetch, decode and execute methods carry out each of the three main stages of the cycle respectively and the `runSingleCycle` and `runProgram` methods will go about running the program given to it, in accordance to the clock.

The clock class is crucial to keep all of the system components, visual or non-visual, in time. The clock determines how long one round of the Instruction Execution cycle takes, and so ultimately decides how long a program will take to run, and consequently, how slow or fast the visualisations should be running. The clock, understandably, is itself a Thread, so it can keep ‘ticking’ asynchronously.

The ALU class maps fairly closely to a real ALU in a MIPS CPU in that it carries out the operations on words of data, such as arithmetic operations or branch comparisons. There is only need for one method in this class, one which takes the two (or one) words of data, and carries out an operation on those words. The other significant CPU component not included in the main CPU class is the main memory. In order to design the main memory, the memory had to be considered in ‘segments’ so an appropriate data structure could be used in each. The `MainMemory` class has four different segments, each a field in the class. The first is the text segment. This represents the code of the program and is easiest represented as a Map such that it is very quick to retrieve instructions at spread out addresses (if a jump instruction is executed for example), and so a map is appropriate as it provides complexities close to that of a hash table. The second ‘segment’ is the static data segment. This is being represented as an array of bytes. The reason for this is that the size of this segment is fixed, and there is also a requirement for flexible access (i.e. one byte or groups of 4 indexes not divisible by 4 for example). Therefore, a standard Java array seems most suitable for this application.

The final two ‘segments’ for the `MainMemory` class are the Stack and the Heap, both of which grow dynamically, and are byte addressable, therefore Java `ArrayList` seemed a reasonable data structure to use, providing the growth element, and byte addressing if Byte is the type of the `ArrayList`. The methods in each of these classes are essentially just intended as read/write methods, with the exception of `sbrk` in the `DynamicDataSegment` class which at a high level is used for memory allocation.

The Program class is another crucial class. It essentially provides all of the information needed by the simulation to run a program, including the new memory layout, and boundary addresses. This information is sent to the simulation from within the assembler component of Simulizer. At a high level, this is almost the equivalent of a compiled class file. It also enables the easy switching of programs, giving CPU objects a level of reusability.

The Decoder and Executor class are reasonably self-explanatory. They contain methods to deal with decoding and executing respectively; they were originally intended to be directly in the CPU class (however, extensive refactoring brought them out). The `ListenerController` is the class deals with the sending of the messages between the simulation and views; it can register a visual component to listen to the CPU and then messages will begin to be sent to that component to process. The IO interface is used for dealing with I/O between the user and the simulation. By using an interface, it allows the creation of different forms of IO for different purposes (an additional use for this was within unit tests).

The last main component in the Simulation is the CPU pipeline class. This class is intended to provide the same functionality as the CPU class so they can be used interchangeably (hence the use of inheritance), but the `CPUPipeline` contains the major difference that the `runSingleCycle` is changed such that the instruction execution is now carried out by way of a 3 stage pipeline, a feature that is particularly desired by Ian Batten.

In addition to the classes used by the simulation as shown above, there are also two groups of algorithms which have proven very useful, but are subtler in use. One of these groups is a set of simulation oriented exception classes. These include `HeapException`, `DecodeException`, `StackException`, `MemoryException`, `InstructionException` and `ExecuteException`. These classes are used to report errors related to their namesake, and when caught, can be used to display error messages to the user, a particularly helpful feature if the written code contains logical errors, rather than syntax errors.

The second group of classes are used for representing instruction formats, such as load instructions, instructions to read/write from registers, jumping instructions, instructions using a base/offset for addressing, and special instructions such as `syscall`. These all have a common base class and are used primarily by the decoder and executer to determine what should be done with a given instruction.

##User Interface Design##

The second important section of the design is that of the User Interface structure, the part of the system that will eventually be linked to the simulation. Fairly on, it was unanimously decided that the interface for the system would take a highly modular approach, with windows that can be switched/modified/resized at the user’s own wish. As well as providing a high level of usability (the user can personalise the system to whatever suits their needs best), it also allows a more straightforward design at the class level. The following is the class diagram for the UI structure:

![UML diagram of user interface](segments/uml-ui.png){width=80%}

The structure of the UI (due to the decision made on modularity) makes this design very hierarchical. The `WindowManager` class manages the separate window that may or may not be open at any given time, as well as dealing with the CPU object currently being used (in the respect that if the user changes the CPU execution type, a new object will have to be created, additionally it may register components to listen to the CPU).

The window interface is used to describe a general template of what any component displaying on screen needs to implement. Any of the ‘modules’ displayed on screen is therefore a Window. Some of the Windows displayed include a window for the logger. The logger is the ‘gateway’ for any input and output between the simulator (as an example, the logger would be used if the user writes a program that calls `syscall` with code 5 to read an integer value into the program). This logger will additionally implement the IO interface discussed previously such that it is compatible with the simulator. The code editor is the window that is the location for the user to write their programs into (and save/load etc.). This window uses the Ace editor to provide an attractive editor (please see ‘A note on external software’). Any other window on screen is additionally a visualisation of some sort and so also has to implement the visualisation interface.

The visualisations part of this diagram are all components on the screen that listen to the CPU such that it can, in some way provide some educational insight into the running of the processor. The `MemoryVisualiser` class will provide an insight into the current states of the data segment, the stack and the heap. The `RegisterVisualiser` will simply look at the contents of all 32 of the general purpose registers (a useful debugging tool alongside the memory view). The `PipelineVisualiser` will display the instructions running through the pipeline, with ‘bubbles’ running through the pipeline on the occurrence of pipeline hazards. The `CPUVisualiser` class is the class which visualises our central visualisation in the application: the MIPS block diagram with the data moving through it and highlighting on the use of specific components such as the ALU.

In addition to the aforementioned visualisations, there are also the high level visualisations, which are the classes which provide the more familiar view of the running of the algorithm the users will be used to. There will be multiple different types of high level visualisation within the system such as list visualisation, towers of Hanoi visualisation etc.

One further part of the design crucial for the complete running of the system concerned how the simulation would be linked to the main interface. As already specified, the Observer/Observable model was not enough for this scenario, and so a few modifications were made to the concepts portrayed by this model. As already described, the simulation is linked to a `ListenerController` that will allow the sending of messages to any component that is registered to listen to it (fairly similar to the Observable model). These components are registered to listen to the CPU at whatever stage a new CPU object is created (regardless of pipelined CPU/non-pipelined CPU etc.). Once the components are all registered to listen, and the CPU starts running a program, then it starts sending messages. These messages are sent whenever something of any significance occurs during execution such as the movement of data or the entering of a new stage of the cycle. There are different types of message the CPU send out on different occasions such as a `DataMovementMessage` or a `StageEnterMessage`, each with different information attached to it. The design suggests that visualisations/windows will only read and process messages of types considered important to them. For example, there is a message type `AnnotationMessage` related to the JavaScript annotation system, and the high level visualisations need only look out for that type of message. There is a concern with designing such a method of communication that, if too much information is included in the message, it will have the consequence of no longer making the system very extensible; the messages are specific to a certain type of visualisation for example. Therefore, decisions were made to go for a minimalistic policy in which the messages give enough information to be useful, yet little enough that visualisations can be completely redesigned without the need for modifying messages (the data movement message is a good example of this; it signals that a piece of data somewhere has moved and gives the data. It doesn’t specify a component being used, this can be inferred if a visualisation decides to process the appropriate messages, the idea is that the simulator has to do no additional ‘work’, the visualisations decide what of the available information they need, and compute the visualisations appropriately based on that).
