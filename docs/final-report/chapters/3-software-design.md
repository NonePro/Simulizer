#Software Design#
##Simulation Design##
A carefully planned and logical design was crucial to ensure the implementation of Simulizer would be manageable. This careful consideration reduced further complexities later in the project. The design of the software, especially the back-end, went through multiple revisions before a final decision was settled upon. In particular, there were initially multiple ideas for the design of the simulation. These were both focused on different aspects of the implementation. One of the proposed designs was to fully and faithfully recreate the MIPS block diagram within Java, with Bus classes used for communication between components and separate classes for every single component (and additionally a thread for each stage of the pipeline). The alternative design was to reduce the entire simulation state into essentially one class, and then have a separate class for the visualisation state. As a first attempt, a compromise was made that kept the highly faithful design but reduced the threading in the pipeline.

A prototype was implemented based on this design in order to test if it was suitable at a lower level. It soon became apparent that this design would not be fully suitable for multiple reasons: Firstly, the method of communication through buses added a lot of unwanted complexity to the simulation. There was also a level of unnecessary encapsulation made in some of the classes (in particular the program counter, which was just a data class, a bad code ‘smell’). This encapsulation would have made the testing of the system incredibly complicated when it needn’t be. Also, it was the design stage that discovered that the Observer/Observable model would not be sufficient to connect the model and views; more information would be needed. Based on this, the design was revised further.

This revised design can be viewed below. The design still aimed for a faithful implementation of the processor but, in some cases, smaller components, such as the program counter are not in their own class, rather they are a field in the main CPU class. This design still kept more complex components separate, but gave a central class to work around. This also allowed the easy sending of messages through this central class and also made the components much easier to unit test, since each major component could be tested in isolation. One could see these revisions as a refactoring for testability. Other features of this design include a much simpler method for changing the operation of the CPU through inheritance and a significantly reduced thread usage, which reduces the complexity of the simulation significantly. The following is the UML class diagram for the simulation design:

<!-- UML Class Diagram here -->
![UML simulation design](segments/uml-simulation.png){width=80%}

In this design, the CPU class is the most important class, providing the central ‘hub’ for all of the other classes in the simulation. With respect to the actual CPU, this class abstractly represents the Control Unit, the Program Counter and the Instruction Register as well as the 32 general purpose registers. At a high level, this class also deals with the Instruction Execution Cycle. The fetch, decode and execute methods carry out each of the three main stages of the cycle respectively and the `runSingleCycle` and `runProgram` methods will go about running the program given to it, in accordance to the clock.

The clock class is crucial to keep all of the system components, visual or non-visual, in time. The clock determines how long one round of the Instruction Execution cycle takes, and so ultimately decides how long a program will take to run, and consequently, how slow or fast the visualisations should be running. The clock, understandably, is itself a Thread, so it can keep ‘ticking’ asynchronously.

The ALU class maps fairly closely to a real ALU in a MIPS CPU in that it carries out the operations on words of data, such as arithmetic operations or branch comparisons. There is only need for one method in this class, one which takes the two (or one) words of data, and carries out an operation on those words. The other significant CPU component not included in the main CPU class is the main memory. In order to design the main memory, the memory had to be considered in ‘segments’ so an appropriate data structure could be used in each. The `MainMemory` class has four different segments, each a field in the class. The first is the text segment. This represents the code of the program and is easiest represented as a Map such that it is very quick to retrieve instructions at spread out addresses (if a jump instruction is executed for example), and so a map is appropriate as it provides complexities close to that of a hash table. The second ‘segment’ is the static data segment. This is being represented as an array of bytes. The reason for this is that the size of this segment is fixed, and there is also a requirement for flexible access (i.e. one byte or groups of 4 indexes not divisible by 4 for example). Therefore, a standard Java array seems most suitable for this application.

The final two ‘segments’ for the `MainMemory` class are the Stack and the Heap, both of which grow dynamically, and are byte addressable, therefore Java `ArrayList` seemed a reasonable data structure to use, providing the growth element, and byte addressing if Byte is the type of the `ArrayList`. The methods in each of these classes are essentially just intended as read/write methods, with the exception of `sbrk` in the `DynamicDataSegment` class which at a high level is used for memory allocation.

The Program class is another crucial class. It essentially provides all of the information needed by the simulation to run a program, including the new memory layout, and boundary addresses. This information is sent to the simulation from within the assembler component of Simulizer. At a high level, this is almost the equivalent of a compiled class file. It also enables the easy switching of programs, giving CPU objects a level of reusability.

The Decoder and Executor class are reasonably self-explanatory. They contain methods to deal with decoding and executing respectively; they were originally intended to be directly in the CPU class (however, extensive refactoring brought them out). The `MessageManager` is the class that deals with the sending of messages between the simulation and views; it can register a visual component to listen to the CPU and then messages will begin to be sent to that component to process. The IO interface is used for dealing with I/O between the user and the simulation. By using an interface, it allows the creation of different forms of IO for different purposes (an additional use for this was within unit tests).

The last main component in the Simulation is the CPU pipeline class. This class is intended to provide the same functionality as the CPU class so they can be used interchangeably (hence the use of inheritance), but the `CPUPipeline` contains the major difference that the `runSingleCycle` is changed such that the instruction execution is now carried out by way of a 3 stage pipeline, a feature that is particularly desired by Ian Batten.

In addition to the classes used by the simulation as shown above, there are also two groups of algorithms which have proven very useful, but are subtler in use. One of these groups is a set of simulation oriented exception classes. These include `HeapException`, `DecodeException`, `StackException`, `MemoryException`, `InstructionException` and `ExecuteException`. These classes are used to report errors related to their namesake, and when caught, can be used to display error messages to the user, a particularly helpful feature if the written code contains logical errors, rather than syntax errors.

The second group of classes are used for representing instruction formats, such as load instructions, instructions to read/write from registers, jumping instructions, instructions using a base/offset for addressing, and special instructions such as `syscall`. These all have a common base class and are used primarily by the decoder and executer to determine what should be done with a given instruction.

##User Interface Design##
$\TODO{Eventually linked? We've done it right?}$
The second important section of the design is that of the User Interface structure, the part of the system that will eventually be linked to the simulation. Fairly on, it was unanimously decided that the interface for the system would take a highly modular approach, with windows that can be switched/modified/resized at the user’s own wish. As well as providing a high level of usability (the user can personalise the system to whatever suits their needs best), it also allows a more straightforward design at the class level. The following is the class diagram for the UI structure:

![UML diagram of user interface](segments/uml-ui.png){width=80%}

The structure of the UI (due to the decision made on modularity) makes this design very hierarchical. The `Workspace` class manages the separate window that may or may not be open at any given time. The `WindowManager` class contains the `Workspace` as well as the `MainMenuBar`. `WindowManager` is the class that deals with the CPU object currently being used (in the respect that if the user changes the CPU execution type, a new object will have to be created, additionally it may register components to listen to the CPU).

The window interface is used to describe a general template of what any component displaying on screen needs to implement. Any of the ‘modules’ displayed on screen is therefore a Window. Some of the Windows displayed include a window for the logger. The logger is the ‘gateway’ for any input and output between the simulator (as an example, the logger would be used if the user writes a program that calls `syscall` with code 5 to read an integer value into the program). This logger will additionally implement the IO interface discussed previously such that it is compatible with the simulator. The code editor is the window that is the location for the user to write their programs into (and save/load etc.). This window uses the Ace editor to provide an attractive editor (please see ‘A note on external software’). Any other window on screen is additionally a visualisation of some sort and so also has to implement the visualisation interface.

The visualisations part of this diagram are all components on the screen that listen to the CPU such that it can, in some way provide some educational insight into the running of the processor. The `MemoryView` class will provide an insight into the current states of the data segment, the stack and the heap. The `Registers` class will simply look at the contents of all 32 of the general purpose registers (a useful debugging tool alongside the memory view). The `PipelineView` will display the instructions running through the pipeline, with ‘bubbles’ running through the pipeline on the occurrence of pipeline hazards. The `CPUVisualisation` is the class which visualises our central visualisation in the application: the MIPS block diagram with the data moving through it and highlighting on the use of specific components such as the ALU.

In addition to the aforementioned visualisations, there are also the high level visualisations, which are the classes which provide the more familiar view of the running of the algorithm the users will be used to. There will be multiple different types of high level visualisation within the system such as list visualisation, towers of Hanoi visualisation etc. These will be discussed further in the 'Visualisation Design' section of this report.

Another crucial component of the simulation is how it communicates to many different components at once. As already discussed, the Observer/Observable pattern was not sufficient for this scenario, and so we sought an alternative approach. The simulation is linked to a `MessageManager` that handles the dispatching and processing of messages sent from the simulation. Components that wish to listen to specific messages register with the `MessageManager`.

Simulizer uses the producer consumer pattern to send a large number of messages very quickly and process them concurrently. Whenever an event occurs within the simulation (producer) creates a new message object and pushes it onto a processing queue managed by the `MessageManager`. The manager manages a thread pool, which contains a dedicated 'dispatching' thread. This thread is the consumer of the processing queue and repeatedly pops messages off of the queue and dispatches the work of processing the message in each of the listeners to other threads in the pool. The manager guarantees that the simulation will not move on to the next cycle before processing of the messages is complete but does not guarantee the order in which messages are processed.

Variations on the approach were trialled, such as each listener processing in a separate thread in the pool, or having multiple dispatching threads. Ultimately these methods required more synchronization which drastically decreased performance, so these prototypes were abandoned.

Each listener of the CPU implements the `SimulationListener` interface and only implements the methods corresponding to the type of message they are interested in.

The messages contain useful information about the type of event. This is used to great effect in the annotation system, which passes the javascript code in the message to the annotation processor which executes it. We tried to keep the information provided as general as possible to make the system extremely extensible. Also information that could easily be looked up using the simulation object was not included for performance reasons.

The data movement message is a good example of our generality. It signals that a piece of data somewhere has moved and gives the data. It doesn’t specify the CPU component which is involved in the transfer (main memory / register file etc) as the simulation has a different concept of these components to the actual hardware. The hardware-faithful behaviour can be inferred in the code for a visualisation that wants to represent that information. The idea behind the system is to perform no additional work to cater to specific listeners. The listeners decide what of the available information they need, and compute the information based on that. This again helps with the extensibility as the simulation has high cohesion. It performs the simulation and little else.

![Message Passing Diagram](segments/MessagePassing.png){width=80%}
