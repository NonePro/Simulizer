#Visualisation Design#
From a usability standpoint, there are certain unwritten HCI rules that makes software feel familiar to a new user. We wanted the UI to be highly flexible, and so we had a look at how this could be achieved. One piece of software that has a very flexible UI is the desktop environment, and users of Simulizer should be very familiar with how that works. We decided to mimic a "desktop like" feel by putting each component of the system in its own "Internal Window". Like a desktop environment, these Internal Windows can be moved, resized and closed based on the user's preference. When the main Simulizer window resizes, all of the Internal windows resize to the new dimensions. This means if the resolution of the screen changes (maybe a projector is connected), then all the Internal Windows resize accordingly, keeping the window layout consistent.

Like a desktop environment, we wanted Simulizer to be customisable. There are many use cases on why customisation is a requirement. Take the example of a colour blind user; a more high contrast theme would be required, and so by adding this functionality we have increased the accessibility of the project. The customisation of this software has been designed to come in many forms. Firstly, at a fine grain level of detail, the user is able to configure screen sizes and initial simulation settings, for example, but also fonts, editor themes etc. At the level of the interface, the user is able to create their own layouts for the software, allowing the user to be able to return to the layout that works best for them. Finally, Simulizer supports the changing of the aforementioned themes, providing an even higher level of customisation: the user can change the system as much or as little as they wish.

The development of a User Interface in such a manner has given strong HCI attributes to the project. The use of internal windows gives a sense of familiarity to the interface. Because of the knowledge that every component in the system can be opened in the same way in its own internal window, the system is consistent, suggesting that, once the user has used the system for a brief time, they will have fully acquired knowledge to utilise the entire system. The consistency of the interface is additionally reinforced via the ability to switch themes/layouts. With a lot of information available, Simulizer has aimed itself on providing clarity throughout its use. This includes helpful error messages should something erroneous occur during the user's time with the system; this is particularly apparent with error messages provided from the simulation to the interface as this in particular was a requirement on improving upon the existing software. Simplicity has also lead to clarity. For example, where possible colour is used instead of text to explain an idea. Further detail is available through the interface but only if the user opts to see it. One final desirable HCI attribute is attractiveness. We believe that Simulizer provides an attractive interface: clean separation of components, and good use of colour has partly achieved this. Another attribute to this is the teams use of JavaFX for the main interface. We believe that JavaFX is a much superior set of libraries for designing interfaces over its competitor, Swing, which to us, doesn't allow the creation of professional looking interfaces.

The system satisfies Nielsenâ€™s Heuristics for HCI. As an example, we keep the user informed about the system status throughout the program: an animated dialog box is displayed while the user's program is being assembled. By having various parts of the system satisfy these heuristics, Simulizer creates an enjoyable experience for the user.

##CPU Visualisation##
The CPU Visualisation is one of the most visual parts of the system, and allows the user to learn a great deal about how the CPU is working on instructions at a low level. For this reason it was crucial that a great level of detail and thought was put into the design in order to provide ease of use.

One of the initial considerations to be made with regards to this visualisation was how it was going to be designed and how it would look. By looking at what content would already be familiar with the user base, it was decided that a reasonably faithful block diagram of the R3000 processor would be most appropriate. However, taking this diagram as is would lead to a highly cluttered visual component being given to the user which is considered highly undesirable. The main reason for this is the excess of communication links within the diagram. As a result of this, these links would be cut down, with only one link from one component to another: this lead to a well justified abstraction of the bus communication of the processor, which has only aided the cause of providing software that is easy to learn from.

When viewing the visualisation, the separate components can easily be seen against the light background and allow the user to quickly get a grasp on how the CPU works. Varying component sizes specify their relative importance, for example the mux unit is small, as this performs simple operations, whereas the registers are large. This allows the user to quickly get an idea of the importance of various components. Different shapes were also used, for example the ALU and adder components are the typical shape shown in existing resources, which allows the user to quickly understand the function of various components. Wires can also be seen on the diagram and link various components together, these wires are easy to see and are all organised and positioned to provide a clean design. Distinct arrowheads can also be seen at the end of each wire, which signifies the direction of flow for data, these are fairly large and allow them to easily be seen by the user.

Tool-tips were used extensively in the CPU block diagram to give more information to the user. These tool-tips show on the hovering of the mouse, allowing them to only show when needed. The tool-tips provide detail about the function for each component, and allow the user to learn more about why different components are needed, for example that the program counter is used to store the address of the next instruction. The tool-tips have a dark background which allows the user to clearly differentiate them from components and allow the information to be read easily.

Once the user starts running the simulation, they will start to see red circles moving along the wires in the block diagram. These red circles are easy to see against the blue wires and show the movement of data/signals through the CPU. The movement of data is also synchronised with the text editor, for example when an instruction is being fetched, the visualisation will animate to show this, and once the editor moves to decode an instruction, the visualisation will also show a decode. The user will also notice components highlighting when the visualisation is running, this shows when a specific component is being used, for example that the ALU is performing a comparison. This works well when combined with the data movement animations and allows the user to see how data is being directed through the CPU.

To provide more information in the visualisation, a rectangular box appears at the top of the visualisation containing different information about the current instruction or stage of the simulation. This box is a different colour to the other CPU components allowing it to be easily distinguished. The box also fades in and out at different points in the simulation, which draws attention to it when required. The information is used to describe instructions and stages, for example that the current value of the program counter is being passed to memory.

Overall the CPU visualisation has many different visual aspects to enhance the user's knowledge and allow them to easily observe how a CPU functions inside a computer. Each instruction in the editor is visualised to show detailed execution information and allows the user to easily learn more about its execution along with the functionality of different components using the informative tool-tips provided.

##Pipeline View##
The pipeline view can be extremely helpful when the user wants to learn about pipelining, which is extremely difficult to learn about using existing resources. The pipeline view is very easy to use, and simply requires that the simulation is being run in pipeline mode, which the user can switch easily.

The basis of the design for this pipeline view arose from existing pipeline diagrams available to the students through common resource sources. By designing the component in such a way, it provided a form of compatibility in the scenario in which the user would like to carry out 'further reading' on pipelining (a very large topic which can go into great detail). Additionally, special attention was made in the design of this component; the team had been informed pipelining was typically a highly difficult topic to teach and so special provisions were made to keep this visualisation simple, only boosting it's ability as a resource for learning and teaching.

When the user is observing the pipeline view, they will immediately notice the different colours of various blocks. These colours are used to show different instructions across different cycles in the pipeline. The different colours allow the user to very quickly see how each instruction is passing through the pipeline. The user can also click on a single instruction, this will highlight the instruction across all cycles and also jump to the correct line inside the editor. More information about each instruction can also be seen by hovering over it with the mouse, data is displayed such as the instruction name, type, address and line number.

Bubbles are shown as red circles in the pipeline view, the colour and shape used allow the user to clearly distinguish them from regular instructions. By hovering over each bubble, the user can see more information about the hazard such as whether it's a control or read after write hazard. Through the including of such a feature, the visualisation provides an easy to understand method of some of the difficulties that make pipelining as a concept difficult.

As the program is running, the pipeline view will start to populate and move along in real time as the program continues to run. This can easily be disabled with the use of a check box to suit the user's preference. The user can also use the left and right arrows to move back to a previous time in the pipeline, or alternatively the user can enter a cycle number to jump to, allowing fast movement along the pipeline.

Overall the pipeline view provides great detail and visual aspects to allow the user to quickly and easily learn more about pipelining, which is extremely difficult with existing resources. The user can easily see different stages of the pipeline such as fetch, decode and execute as well as see how instructions are moving through the different stages, as well as the pipeline hazards that occur.

##Editor##
Because our user base of computer science students and lectures will be familiar with an IDE (integrated development environment), we thought that we should follow some of those conventions. One of the first features that people notice when they open an IDE is syntax highlighting. Syntax highlighting provides a link between what the code does and colour. This creates makes code more readable as it provides the user with instant recognition. The syntax highlighting in Simulizer is based heavily upon the grammar of the assembly language, therefore providing highly appropriate and understandable highlighting for different cases.

The second feature that people notice about IDE's is error checking. Simulizer notifies the user of a mistake in their code by putting a red box around the mistake. Simulizer also puts a red X in the gutter (alongside the line numbers). When the user hovers over the X, they are presented with more information about the error. We felt it was important to not display the error all the time as the user might want to work on another part of the program before fixing the error. The designing of the interface to include this was yet another bid to improve upon Spim Simulator, and providing the error messages in this way not only achieved this, but additionally provided familiarity with the Eclipse IDE, which the majority of 2nd year Computer Science students will have had experience with.

When a program is running, the current line that is being fetched/decoded/executed is highlighted in the gutter. We used colours on the red to green scale to indicate the process that each line needs to go through to be finally executed. Green indicates fetch, orange decode and red execute. These colours can be hovered over to describe to the user which stage each colour represents (more of as a reminder than as something that they will need to see all of the time). These descriptions were a HCI design decision made upon the request of a user who had tried out the system.

##Program I/O##

The Program I/O had a few design choices to improve its usability. The first iteration of the I/O logger was very primitive. It had a log of the simulation output as well as a method for the user to input data into the simulation. While this was functional, it did not meet our high standards for the interface. For example, we found that we didn't notice when the simulation was waiting for an input. This issue was dealt with by emphasising the Program I/O when input is required. This increased its usability drastically, but we felt more could be done.

We had a look at the information that was being input/output to the logs, and realised that both MIPS and annotation outputs were being sent to the same place. We decided that we should split these into different "streams" of information in the Program I/O to make it clear to the user where each message came from. Since it is only possible to see one of these streams at once, we notify the user with a red dot next to the tab when something is posted to that stream. When running a large program, this makes information output from your program much easier to digest, also removing any potential confusion. If, for example, a user has set many logs to the logger using the JavaScript annotations, then they can focus their attention on that stream.

##High Level##
We felt that the high level visualisations needed to be very colourful, in order to describe what is going on through animation. During the project we wrote two different high level visualisations, one for visualising Towers of Hanoi and one for list visualisation. Both of these visualisations allow for swapping of elements/discs. These swaps are animated so that the user can see where the item started off, and trace it through to where it ends up.

For the Hanoi visualisation, each disc has a different colour (as well as a different size) to easily distinguish between them. This is a lot more visual and usable than having all of the discs look the same and putting a number in each disc.

The list visualisation is a more general visualisation and therefore has a few more HCI components. There are emphasis and markers. Emphasis is a way to attract the users attention to a particular element of the list. It does this by flashing that element red. Red is a very prominent colour that can be easily seen in frontal vision. The reason we flash the colour is to produce a sense of movement which can attract the users attention when the element is in the users peripheral vision.

One of the major design points of these visualisations (and arguably of the whole system) is the generality provided by their design. The list visualisation, for example, isn't hard coded to work with a single algorithm, it can be used for any list-based algorithm that wishes to use it. This is because these visualisations are controlled by the user; specifically the JavaScript annotations they add into their programs. If the user were to write insertion sort in MIPS for example, then they could use the same visualisation for this purpose, annotating the necessary points in their code. These visualisations can be designed and developed completely independently from the rest of the system and then easily integrated with the existing visualisations. This design choice provides incredible extensibility to the system, with the possibility of more complex visualisations being added such as graphs and frames. Furthermore, once this system is released under a public license, any user could potentially contribute to adding new visualisations without modifying the underlying system. The generality is provided because this allows any algorithm to be visualised and an arbitrary number of visualisations to be created. Therefore, this is considered one of the major selling points of this system with regards to the visualisation design.
