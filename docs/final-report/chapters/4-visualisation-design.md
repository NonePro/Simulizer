#Visualisation Design#
From a usability standpoint, there are certain unwritten HCI rules that makes software feels familiar to a new user. We wanted the UI to be very flexible, and so we had a look at how this could be achieved. One piece of software that has a very flexible UI is the desktop environment, and users of Simulizer should be very familiar with how that works. We decided to mimic a "desktop like" feel by putting each component of the system in it's own "Internal Window". Like a desktop environment, these Internal Windows can be moved, resized and closed based of the users preference. When the Main Simulizer window resized, all of the Internal windows resize to the new dimensions. This is so that if the resolution of the screen changes (maybe a project is connected), then all the Internal Windows resize to match the changes, and keep the Window layout consentient.

Like a desktop environment, we wanted Simulizer to be customisable. There are many use cases on why customisability is a requirement. On example would be a colourbind user. They would prefer a more high contrast theme, and so by adding this functionality we have increased the accessibility of the project.

##CPU Visualisation##
The CPU Visualisation is one of the most visual parts of the system, and allows to user to learn a great deal about how the CPU is working on instructions at a low level. For this reason it was crucial that a great of detail and thought was put into the design to allow ease of use for the user.

When viewing the visualisation, the separate components can easily be seen against the light background and allow the user to quickly get a grasp on how the CPU works. Various components are different sizes to highlight their relative importance, for example the mux unit is small, as this performs simple operations, whereas the registers are large. This allows the user to quickly get an idea of the importance of various components. Different shapes were also used, for example the ALU and adder components are the typical shape shown in existing resources, which allows the user to quickly understand the function of various components. Wires can also be seen on the diagram and link various components together, these wires are easy to see and are all organised and positioned to provide a clean design. Distinct arrowheads can also be seen at the end of each wire, which signifies the direction of flow for data, these are fairly large and allow them to easily be seen by the user.

Tooltips were used extensively in the CPU block diagram to give more information to the user. These tooltips show on mouseover, allowing them to only show when needed. The tooltips provide detail about the function for each component, and allow the user to learn more about why different components are needed, for example that the program counter is used to store the address of the next instruction. The tooltips have a dark background which allows the user to clearly differentiate them from components and allow the information to be read easily.

Once the user starts running the simulation, they will start to see red circles moving along the wires in the block diagram. These red circles are easy to see against the blue wires and show the movement of data/signals through the CPU. The movement of data is also synchronised with the text editor, for example when an instruction is being fetched, the visualisation will animate to show this, and once the editor moves to decode an instruction, the visualisation will also show a decode. The user will also notice components highlighting when the visualisation is running, this shows when a specific component is performing an operation, for example that the ALU is performing a comparison. This works well when combined with the data movement animations and allows the user to see how data is being directed through the CPU.

To provide more information in the visualisation, a rectangular box appears at the top of the visualisation containing different information about the current instruction or stage of the simulation. This box is a different colour to the other CPU components allowing it to be easily distinguished. The box also fades in and out at different points in the simulation, which draws attention to it when required. The information is used to describe instructions and stages, for example that the current value of the program counter is being passed to memory.

Overall the CPU visualisation has many different visual aspects to enhance the user's knowledge and allow them to easily observe how a CPU functions inside a computer. Each instruction in the editor is visualised to show detailed execution information and allows the user to easily learn more about it's executed along with the functionality of different components using the informative tooltips provided.

##Pipeline View##
The pipeline view can be extremely helpful when the user wants to learn about pipelining, which is extremely difficult to learn about using existing resources. The pipeline view is very easy to use, and simply requires that the simulation is being run in pipeline mode, which the user can switch easily.

When the user is observing the pipeline view, they will immediately notice the different colours of various blocks. These colours are used to show different instructions across different cycles in the pipeline. The different colours allow the user to very quickly see how each instruction is passing through the pipeline. The user can also click on a single instruction, this will highlight the instruction across all cycles and also jump to the correct line inside the editor. More information about each instruction can also be seen by hovering over it with the mouse, data is displayed such as the instruction name, type, address and line number.

Bubbles are shown as red circles in the pipeline view, the colour and shape used allow the user to clearly distinguish them from regular instructions. By hovering over each bubble, the user can see more information about the hazard such as whether it's a control or read after write hazard.

As the program is running, the pipeline view will start to populate and move along in real time as the program continues to run. This can easily be disabled with the use of a check box to suit the user's preference. The user can also the left and right arrows to move back to a previous time in the pipeline, or alternatively the user can enter a cycle number to jump to, allowing fast movement along the pipeline.

Overall the pipeline view provides great detail and visual aspects to allow the user to quickly and easily learn more about pipelining, which is extremely difficult with existing resources. The user can easily see different stages of the pipeline such as fetch, decode and execute as well as see how instructions are moving through the different stages, as well as the pipeline hazards that occur.

##Editor##
Because our user base of computer science students and lectures will be familiar with an IDE (integrated development environment), we thought that we should follow some of those conventions. One of the first features that people notice when they open an IDE is syntax highlighting. Syntax highlighting provides a link between what the code does and colour. This creates makes code more readable as it provides the user with instant recognition.

The second feature that people notice about IDE's is error checking. Simulizer notifies the user of a mistake in their code by putting a red box around the mistake. Simulizer also puts a red X in the gutter (where all the line numbers are). When the user hovers over the X, they are presented with more information about the error. We felt it was important to not display the error all the time as the User might want to work on another part of the program before fixing the error.

When a program is running, the current line that is being fetched/decoded/executed is highlighted in the gutter. We used colour s on  the red to green scale to indicate the process that each line needs to go through to be finally executed. These colours can be hovered over to describe to the user which stage each colour represents (more of as a reminder than as something that they will need to see all of the time).

##Program I/O##

The Program I/O had a few design choices to improve it's usability. When we first added the Program I/O, it was very basic. It had a log of all the stuff the simulation outputted, and a way for the user to input data into the simulation. While this was functional, it was not up to our standards. For example, we found that we didn't notice when the simulation was waiting for an input. We fixed this issue by emphasising the Program I/O when input is required. This increased it's usability drastically, but we felt more could be done.

We had a look at the information that was being input/output to the logs, and realised that both MIPS and annotation outputs were being sent to the same place. We decided that we should split these different "streams" of information in the Program I/O to make it clear to the user where each message came from. Since it is only possible to see one of these streams at once, we notify the user with a red dot next to the tab when something is posted to that stream.

##High Level##
We felt that the high level visualisations needed to be very colourful, and describe what is going on through animation. During the project we managed to write two different high level visualisations, one for visualising towers of hanoi and the other is for list visualisation. Both of these visualisations allow for swapping of elements/discs. These swaps are animated so that the user can see where the item started off, and trace it through to where it ends up.

For the Hanoi visualisation, each disc has a different colour (as well as a different size) to easily distinguish between them. This is a lot more visual and usable than having all of the discs look the same and putting a number in each disc.

The list visualisation is a more general visualisation and therefore has a few more HCI components. There are emphasis and markers. Emphasise is a way to attract the users attention to a particular element of the list. It does this by flashing that element red. Red is a very prominent colour that can be easily seen in frontal vision. The reason we flashing the colour is to produces a sense of movement which can attract the users attention when the element is in the users peripheral vision.
