Introduction
============
The following report aims to discuss and analyse the inception and creation of Simulizer, a piece of software with the goal of visualising and simulating a MIPS style processor. This report also looks into the team and its organisation such that Simulizer can be delivered as a finished piece of software. 

The original motivation for such a project arose from a second year Computer Science module taught at the University of Birmingham titled ‘Computer Systems & Architecture’. This module aims to teach students about ‘the fundamental concepts and principles of computer architectures’ as well as to ‘introduce the basic components of computer systems, their internal design and operation and their interactions’ (School of Computer Science, 2015). During the early stages of this module (which 4 out of 5 members of the development team are students of), the inner workings of a processor are taught, with emphasis on topics such as the components of a CPU, the Instruction Execution cycle, pipelining and also how to write basic assembly code to replicate some of the algorithms the students are already familiar with from their first year of study.

The learning of the aforementioned topics uses a particular type of processor as example – a MIPS processor (particularly the R4000). For this reason, it was MIPS assembly code that the students are taught to write. In particular, it is worth noting that an assignment is given to the students in order to test their understanding; implementing a familiar algorithm in assembly is their task (previous algorithms used have been bubble sort and binary search). 

Due to the fact that it is unlikely students will have a MIPS processor to use for this assembly level programming, they are recommended to use a simulator, named Spim Simulator, a ‘self-contained simulator that runs MIPS32 programs. It reads and executes assembly language programs written for this processor’ (Larus, 2011). Although undeniably a piece of software the students can use to run their code to test its functionality, Spim Simulator does not contain much of a visual aspect to it: everything displayed in the software is largely text-driven, with the different segments of primary memory and the register contents shown as text displays. The majority of the motivation for Simulizer has come from this point.

The Computer Systems & Architecture module contains a lot of content that is completely new to students, who, based on their first year studies, won’t have dealt with anything at such a low level before. This lead to the idea of Simulizer: as well as providing a usable interface to running your own MIPS assembly program, it would be beneficial to students if in-depth visualisations of the processor were running asynchronously with the running of their program. This could allow a level of reinforcement of the content taught in lectures, and would even potentially allow a visual aid during lectures.

In order to gauge the interest and potential benefit of a system like Simulizer, communications were held with the module leader for Computer Systems & Architecture (Dr Ian Batten). From such conversations, it was gathered that there were certain areas which either students generally found difficult to understand, or that were difficult to teach, a topic where this was apparent in both cases was pipelining fir example. From these discussions, the functionality and goals of Simulizer were determined.

There are two crucial aspects to this project which need to be explicitly identified and that is the algorithm selected and how it is going to be visualised. At the highest level (or rather lowest level), the algorithm being analysed is the Instruction Execute cycle in both non-pipelined and pipelined form. This algorithm is crucial for enabling any other algorithm/program to run on any computer via the use of specific components and appropriate movement of data across a processor and so is a suitable algorithm for visualisation. Additionally, the MIPS programs themselves will indeed contain algorithms, which will be visualised through the visualisation of the processor, as well as other means. What this enables are the ability to in fact use any algorithm which will be converted into a form that will be input into the ‘main’ algorithm being used for this project.

Visualisation is also a critical aspect of this project (for specification reasons as well as making a highly usable system) and so Simulizer contains multiple different forms of visualisation. The Instruction Execute cycle is being visualised via the movement of data and use of components on a fairly typical block diagram of a MIPS processor. As an example, for an add instruction, one might see data being read from the registers and being taken to the ALU, computations being carried out, and then the result being written back to a specific register. In addition to this, there are visualisations with more specific intentions. Simulizer provides a visualisation of a pipeline (i.e. instructions moving through the pipeline and specific hazards being shown as ‘bubbles’ in the pipeline). In complement to this, the information provided by Spim Simulator with regards to register and memory contents will also be viewable. At a higher level, Simulizer displays the algorithms being run in the MIPS programs via the use of appropriate data structures such as lists, graphs, disks etc. This allows a reinforcement of first year algorithms a student has learned as well as providing a cross-reference for the Instruction Execution visualisation.

As a general overview, this report intends to explain in detail, the processes and techniques used during the creation of Simulizer, as well an explanation of how it was made. This will involve discussing how the back-end of the system was designed, how the UI and visualisations were designed using good HCI techniques, and the Software Engineering practices used during the project to maximise the quality of the software. As well as this, a full evaluation of the project will be provided, along with the methods used to ensure good performance as a team. Finally, at the end of this report, one can find a summary and reflection from each of the 5 team members on how the project went for them personally.

