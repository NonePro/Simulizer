#Introduction#
This report aims to discuss the inception and creation stages of our project Simulizer; a piece of software with the goal of visualising and simulating a MIPS-style processor. This report will also analyse the team behind the project, how the project was organised and the decisions the team had to make to bring the software to light.

##Task##
Our task was to select an algorithm and visualise it somehow. We tried to think outside the box with our choice of algorithm, challenging the brief set in the process. The Instruction Execute Cycle in both non-pipelined and pipelined form was the algorithm we picked as it is crucial for enabling any other algorithm/program to run on a computer. The algorithm uses specific components and appropriate data movement across a processor which makes the algorithm suitable for visualising. Additionally, the MIPS programs themselves will indeed contain algorithms, which will be visualised through the visualisation of the processor, as well as other means. What this enables is the ability to, in fact, use any algorithm which will be converted into a form that will be input into the ‘main’ algorithm being used for this project. $\TODO{Maybe reword the last sentence a little bit? I'm not sure I understand it completely}$

Software packages exist which allow the user to run their own MIPS programs, for example [Spim Simulator](http://spimsimulator.sourceforge.net), but we felt it was lacking in features, functionality, and usability. Therefore, we set our sights on developing a system that would improve on these aspects. In addition, by comparing our system to Spim, it allowed us to check that we were not losing functionality or compatibility.

Visualisation is also a critical aspect of this project (for specification reasons as well as making a highly usable system), so Simulizer contains multiple forms of visualisation. The Instruction Execute Cycle is being visualised via the movement of data and use of components on a fairly typical block diagram of a MIPS processor. As an example, for an add instruction, one might see data being read from the registers and being passed to the ALU. The computations would then be seen, and the result written back to a specific register. In addition to this, there are visualisations with more specific intentions. Simulizer provides a visualisation of a pipeline (i.e. instructions moving through the pipeline and specific hazards being shown as ‘bubbles’ in the pipeline). In complement to this, the system will provide information equivalent to Spim Simulator with regards to register and memory contents, and this will also be viewable. At a higher level, Simulizer displays the algorithms being run in the MIPS programs via the use of appropriate data structures such as lists, graphs, disks etc. This allows a reinforcement of rudimentary algorithms familiar to to a student student, as well as providing a cross-reference for the Instruction Execution visualisation.

##Motivation##
The original motivation for the project arose from a second year Computer Science module ‘Computer Systems & Architecture’ taught at the University of Birmingham. The module aims to teach students about ‘the fundamental concepts and principles of computer architectures’ as well as to ‘introduce the basic components of computer systems, their internal design and operation and their interactions’ (School of Computer Science, 2015). During the early stages of this module (of which 4 out of 5 members of the development team are students), the inner workings of a processor are taught. There is an emphasis on topics such as the components of a CPU, the Instruction Execution cycle, pipelining and also how to write basic assembly code to replicate some of the algorithms learnt in the first year of study.

$\TODO{Not entirely happy with this paragraph. Spim is introduced in the Task, and again here. Also the last sentence "which point?"}
During the CPU sections of the module (which focus mainly on the MIPS R4000 processor) students are taught to write assembly code. Because they are unlikely to have a physical MIPS processor to use, it is recommended that they use a simulator named Spim Simulator. Spim is a ‘self-contained simulator that runs MIPS32 programs. It reads and executes assembly language programs written for this processor’ (Larus, 2011). Although the students can test the functionality of their assembly code using Spim, it doesn't give them much of a visual aspect of what their program is actually doing. Everything displayed in the software is largely text-driven, with the different segments of primary memory and the register contents shown as text displays. This makes the assignment to implement a familiar algorithm in assembly at lot more difficult when Spim is used (previous algorithms assignments have been bubble sort and binary search). The majority of the motivation for Simulizer has come from this point.

The Computer Systems & Architecture module contains a lot of content that is completely new to students who, based on their first year studies, won’t have dealt with anything at such a low level before. This lead to the idea of Simulizer: as well as providing a usable interface to running your own MIPS assembly program, it would be beneficial to students if in-depth visualisations of the processor were running asynchronously with the running of their program. This allows for a level of reinforcement of the content taught in lectures, and would even potentially allow a visual aid during lectures.

##Interest##
In order to gauge the interest and potential benefit for this system, communications were held with the module leader for Computer Systems & Architecture (Mr Ian Batten). It was gathered that there were certain areas of the module that students either found difficult to understand, or the lecturer found difficult to teach: the most challenging topic being pipelining. From these discussions, the functionality and goals of Simulizer were determined.

##Overview##
As a general overview, this report intends to explain in detail the processes and techniques used during the creation of Simulizer and its assembly language (which we call ‘SIMP'), as well an explanation of how it was made. This will involve discussing how the back-end of the system was designed. As well as this, a full evaluation of the project will be provided, along with the methods used to ensure good performance as a team. Good HCI techniques were used to design the user interface and the visualisations, and the Software Engineering practices used helped to maximise the quality of the software. Finally, at the end of this report, one can find a summary and reflection from each of the 5 team members on how the project went for them personally. Attached as an appendix to this report are further useful documents, such as textual use cases, persona and further UML class diagrams.
