#Introduction#
This report aims to discuss the inception and creation stages of Simulizer; a piece of software with the goal of visualising and simulating a MIPS style processor. This report will also analyse the team behind the project, how the project was organised and the decisions the team had to make to bring the software to light.

##Task##
Our task was to select an algorithm and visualise it somehow. At the highest level (or rather lowest level), the algorithm being analysed is the Instruction Execute cycle in both non-pipelined and pipelined form. This algorithm is crucial for enabling any other algorithm/program to run on any computer via the use of specific components and appropriate movement of data across a processor and so is a suitable algorithm for visualisation. Additionally, the MIPS programs themselves will indeed contain algorithms, which will be visualised through the visualisation of the processor, as well as other means. What this enables are the ability to in fact use any algorithm which will be converted into a form that will be input into the ‘main’ algorithm being used for this project.

Visualisation is also a critical aspect of this project (for specification reasons as well as making a highly usable system) and so Simulizer contains multiple different forms of visualisation. The Instruction Execute cycle is being visualised via the movement of data and use of components on a fairly typical block diagram of a MIPS processor. As an example, for an add instruction, one might see data being read from the registers and being taken to the ALU, computations being carried out, and then the result being written back to a specific register. In addition to this, there are visualisations with more specific intentions. Simulizer provides a visualisation of a pipeline (i.e. instructions moving through the pipeline and specific hazards being shown as ‘bubbles’ in the pipeline). In complement to this, the information provided by Spim Simulator with regards to register and memory contents will also be viewable. At a higher level, Simulizer displays the algorithms being run in the MIPS programs via the use of appropriate data structures such as lists, graphs, disks etc. This allows a reinforcement of first year algorithms a student has learned as well as providing a cross-reference for the Instruction Execution visualisation.

##Interest##
In order to gauge the interest and potential benefit for this system, communications were held with the module leader for Computer Systems & Architecture (Dr Ian Batten). It was gathered that there were certain areas of the module that students either found difficult to understand, or the lecturer found difficult to teach: the most challenging topic being pipelining. From these discussions, the functionality and goals of Simulizer were determined.

##Motivation##
The original motivation for the project arose from our second year Computer Science module ‘Computer Systems & Architecture’ taught at the University of Birmingham. The module aims to teach students about ‘the fundamental concepts and principles of computer architectures’ as well as to ‘introduce the basic components of computer systems, their internal design and operation and their interactions’ [(School of Computer Science, 2015)][1]. During the early stages of this module (which 4 out of 5 members of the development team are students of), the inner workings of a processor are taught, with emphasis on topics such as the components of a CPU, the Instruction Execution cycle, pipelining and also how to write basic assembly code to replicate some of the algorithms learnt in the first year of study.

During the CPU sections of the module (which focus mainly on the MIPS R4000 processor) students are taught to write assembly code. Because they are unlikely to have a physical MIPS processor to program on it is recommended that they use a simulator named Spim Simulator. Spim is a ‘self-contained simulator that runs MIPS32 programs. It reads and executes assembly language programs written for this processor’ [(Larus, 2011)][2]. Although the students can test the functionality of their assembly code using Spim, it does give them much of a visual aspect of what the program is actually doing. Everything displayed in the software is largely text-driven, with the different segments of primary memory and the register contents shown as text displays. This makes the assignment to implement a familiar algorithm in assembly at lot more difficult in Spim (previous algorithms assignments have been bubble sort and binary search). The majority of the motivation for Simulizer has come from this point.

The Computer Systems & Architecture module contains a lot of content that is completely new to students who, based on their first year studies, won’t have dealt with anything at such a low level before. This lead to the idea of Simulizer: as well as providing a usable interface to running your own MIPS assembly program, it would be beneficial to students if in-depth visualisations of the processor were running asynchronously with the running of their program. This could allow a level of reinforcement of the content taught in lectures, and would even potentially allow a visual aid during lectures.

##Overview##
As a general overview, this report intends to explain in detail, the processes and techniques used during the creation of Simulizer, as well an explanation of how it was made. This will involve discussing how the back-end of the system was designed, how the UI and visualisations were designed using good HCI techniques, and the Software Engineering practices used during the project to maximise the quality of the software. As well as this, a full evaluation of the project will be provided, along with the methods used to ensure good performance as a team. Finally, at the end of this report, one can find a summary and reflection from each of the 5 team members on how the project went for them personally.

[1]: http://www.cs.bham.ac.uk/internal/modules/2015/19340/ "(School of Computer Science, 2015)"
[2]: http://pages.cs.wisc.edu/~larus/spim.html "(Larus, 2011)"
