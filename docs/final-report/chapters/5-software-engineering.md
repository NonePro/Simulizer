#Software Engineering/Risk Assessment#
In order to ensure a high-quality piece of software was produced at the end-point of this project, various software engineering practices have been employed. These practices vary from the way we organised our time developing the system, to how we ensured our code was easy to read/understand and maintainable.

One of the early software engineering related choices to be made within the project was the question of what development model was going to be followed. This project has had a relatively short lifespan and so a model was required that would deal with this well, as well as putting safeguards in with respect to some of the risk assessment carried out on the project. For this reasons, an Agile method of development seemed best suited to this project and its team.

Following an Agile methodology allowed the incremental development of the system in short sprints. This was an effective model for Simulizer due to its highly modular design: one week could produce one new visualisation module by one team member for example, and the next week could produce another. The previous week’s work could be completed, and, in many cases, the next weeks work by that team member wouldn’t too heavily depend on the previous weeks (an exception to this would be the model/CPU simulation, which was built in parts, over multiple sprints, and these parts unavoidably have to depend on other parts in some cases). The sprint length throughout the project did vary very slightly but only between sprint lengths of either 1 week or 2. The length of specific sprints would be determined at team meetings (which occurred on the same day as our sprint start date; Tuesday), dependent on what increment(s) needed to be completed next. As an example to this, the first major development sprint lasted two weeks for the reason that a lot of initial infrastructure needed to be put into place such as the basic model layout. In contrast, the sprint to finish a prototype was strictly a week long: the overarching goal of the sprint was to achieve a working prototype to be demonstrated (something which was a success due to a well-planned out development schedule; looking at the whole project plan signalled that we were exactly on time with regards to project progress at that point).

Another advantage found through the use of an Agile development cycle was the ease of integration with risk minimisation strategies. Due to the high level of functionality required by Simulizer, very comprehensive risk analysis had to be carried out on the potential project to ensure that, if any significant issues arose during development, they would be dealt with in an appropriate fashion (the risk analysis for the project can be found in the systems specification document). One of the most straight-forward techniques for minimising risk was by way of compromise – cutting out some of the functionality of the system. With an Agile methodology, if the team is behind time, then the tasks of one members work for a given week can be removed and that team member can be re-focused on to a higher priority task that needs to be done/finished. Fortunately, (quite possibly due to the benefits of an Agile model), no such compromises have had to be made within the development cycle and in fact, Simulizer contains more functionality (particularly in its educational and visual aspect) than the original specification submitted documented (all additional functionality is documented in the final specification).

Yet another risk identified in the project was the risk accompanying if the project wasn’t favoured by users. The solution/avoidance for this was through the good software engineering practice of simply interacting with the users of the system (outside of simple user testing). In the case of user interaction, the main source of information was Ian Batten. Throughout the project, semi-regular discussions would be held with Ian regarding certain aspects of the system, what would be desirable from his point of view or whether a component of Simulizer is giving sufficient information to educate students. In addition to this, after the point of having prototype, he would receive demonstrations of the system, and in particular, aspects which would be of particular use to him. Through the use of this practice of user interaction, any user based risk was reduced significantly (as an aside, another risk identified was due to the project being built only shortly after learning the concepts initially; discussions with Ian were also an avoidance strategy for this risk, and having such conversations aided significantly with some of the more conceptually challenging areas of the system (the pipeline being one of them)).

As well as using well-known software development models and keeping in good contact with Simulizer’s user base, another software engineering practice employed (and one which proved to be incredibly useful) was that of design patterns, particularly with respect to the linking of the model and the views of the system. In particular, a pattern very similar to the Model View Control pattern was used, albeit with a couple of modifications made to it to make it more suitable for this project. The modifications made (as discussed in the Software Design section of this report) were to add information to the messages sent from the model; if implementing the MVC pattern in Java, one would normally use the Observer/Observable model to implement the communications between the model and view. However, if this was done between the CPU simulation and the various views, computational complexity would have increased drastically as the views would have to completely examine the simulation state on every message send. Alternatively, the information necessary is sent along with the message to improve the efficiency of dealing with the message sending and linking the model and views in a clean manner.

The use of design patterns gave a much desired attribute to Simulizer: low levels of coupling. This loose coupling is most apparent in the splitting up of the model and view(s) of the system. As testament to this, the CPU visualisation and the CPU simulation were developed completely independently of each other. The CPU simulation had been tested fully, and the CPU visualisation had been visually tested to ensure all animations were working as intended. Once it was guaranteed that both of these components were stable, then they were linked together (essentially by the visualisation registering to listen to the simulator). However, this wasn’t something carried out until week 8 of the project (relatively late in) and it shows how little these components actually depend on each other’s internal workings.

As another valuable software attribute, Simulizer also enforces high cohesion. The main cause for this was the way in which Simulizer was designed. In the design stage of the project, multiple designs were considered (for the simulation in particular), and the end design was in fact reasonably faithful to the standard block diagram for a MIPS processor (the same one displayed as part of the visualisation). In being faithful, while avoiding unnecessary levels of encapsulation for the sake of being faithful, all of the components/classes have a very easy to explain reason for having the functionality it does, and the links to the objects it does. As an example, the CPU class has the methods fetch, decode and execute, and a memory object as a field in the class. The CPU needs to be able to access memory and also needs to be able to carry out the Instruction Execution cycle, and so the structure here is very clear, making the entire class structure very easy to understand.

Having gained these valuable attributes has significantly aided in the challenge to make Simulizer a maintainable and extensible piece of software. The low coupling between the model and view alone creates a very maintainable system: if, for example, JavaFX (the library used for the UI) was to become deprecated, then only the view would have to be updated; the model is still completely usable. With regards to extensibility, the system is highly modular in nature. If for example, a developer wanted to have a longer pipeline, then it would be straightforward to do. All that would have to be done is create a new class extending the base CPU class, in particular extending the `runSingleCycle` method; the rest of the code is fully reusable. Another sign of extensibility in the system is how simple it is to add a new high-level visualisation. As an example, if someone wanted to add a visualisation for the travelling salesman problem for example, they would only have to do 4 things: Firstly, they would have to write whatever visual aspects they would like to see in JavaFX. Secondly, they would have to implement the algorithm in MIPS assembly code. The third step is to add any annotations using Simulizer’s JavaScript annotation system to interact with the visualisation (messages sent from the simulation). Finally, the visualisation should listen to the simulation and that’s it. A new visualisation has been added with no real changes to any of the existing code base.

Most of the software engineering practices/issues discussed so far have been more at the level of good design properties providing high quality software. However, at a lower level of the code base, practices have been used to ensure the actual code produced is of a high quality and is readable. The general tactics of suitable commenting and code documentation through Javadoc have been employed, as have keeping names of methods and variables meaningful. Every class and method has a description of its purpose before it’s declared and names such as `programCounter` and `instructionRegister` are used as field names, rather than un-helpful names such as `x1`, `x2` etc. Enforcing a good code style has only helped make the system more understandable to an external developer/user reading it: it gives an easy link to the design documentation as well as giving a detailed insight into the way the software behaves in use. As well as this, a common code format has been used within the team: individual members of the team can write in whatever format/style they desire, but in order to give commonality to the finished code base, format files have been created to be used on the code, to make every Java file conform to every other in terms of code format, improving the code readability further.
